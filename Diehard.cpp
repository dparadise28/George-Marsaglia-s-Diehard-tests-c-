/*
This program uses one of George Marsaglia’s Diehard tests to acess two
random number generators (MWC and MT). It does so by looking at random
permuations of 8d vectors. After figuring out the order types of the
random vectors genetated it stores them in the appropriate bin. The
test then requires you to normalize the Xm counters (which then turn
into Zm). This is used to find the z statistic. The closer the Z
statistic generated by the random number generator is the better it
performs
*/

// This file includes some standard C & C++ library functions and
// declares the functions found in "4135FunctionLibrary".
#include "4135FunctionDeclarations.h"
#include<iostream>
#include<cstdlib>
#include<iomanip>
#include<cmath>

// MTUniform is the Mersenne twister, MWCUniform is the multiply with carry
//    generater that we discussed in class.
#define U1 MWCUniform
#define U2 MTUniform
using namespace std;

//n is a global variable that represents the number of simulations
int n=200000000;

/*
Function declarations (functions found below):
     _____________________________________________________________________
    |OrderType-is a function that takes 8 doubles and returns an integer  |
    |---------------------------------------------------------------------|
    |Xm       -is a funnction that takes 2 double arrays and manipulates  |
    |          them accordingly                                           |
    |----------------------------------------------------------------------
    |Normalize-takes one array of doubles and normalizes each of the      |
    |          elements in the array                                      |
    |---------------------------------------------------------------------|
    |Phat     -takes two arrays and approximates p_i                      |
    |---------------------------------------------------------------------|
    |print    -takes in 2 arrays and prints them                          |
    |---------------------------------------------------------------------|
    |printN  -has no peramiters and is used to print specific probailities|
    |_____________________________________________________________________|
                Note: arrays are always passed by referance
*/
int OrderType (double, double, double, double, double, double, double, double);
void Xm       (double[], double[]);
void Normalize(double[]);
void Phat     (double[], double[]);
void print    (double[], double[]);
void printN   ();
double N      (double);

main()
{
    /*
    Initialize arrays for the diehard test:

        Zm_MWC is an array used to store how many times each of the 40320
        permutations of the random 8d vector occurs(8d random vector is
        generated using the MWCUniform-Multiply with carry-random number
        genetator)

        Zm_MT serves the same purpose as Zm_MWC only instead the components
        of the 8d randome vector are now generated by the MTUniform
        (MERSENNE TWISTER) random number generator.


        Pi_MWC and Pi_MT are arrays that that store the fraction of times
        the Z statistic falls between i and i+1 for the random vecotrs were
        i ranges fron -4 to 4. These values should approximate the p(i<z<i+1)
    */
    double Zm_MWC[40320], Zm_MT[40320], Pi_MWC[8], Pi_MT[8];

    /*
        The function Xm uses the function ordertype to indecate and store (in
        the arrays Zm_MWC and Zm_MT respectively) the number of randomly
        generated 8d vectors that fall in the approprate bin. As arrays are
        passed by referance there are no coppies of the arrays sent to the
        function. This means the array is also changed in the main function.
    */
    clock_t start=clock();
    Xm(Zm_MWC,Zm_MT);

    /*
        The function Normalize standardizes each of the values in the Zm
        arrays (they only indecated the number that fall in the respective bin
        according to order types and are normalized after passed into the
        function). This is done for both arays.
    */
    Normalize(Zm_MWC); Normalize(Zm_MT);

    /*
        Phat finds and stores in the respective slots the fraction of times
        the Z statistic falls between i and i+1,for i ranging between -4 - 3,
        in the arrays Pi_(MWC,MT).
    */
    Phat(Zm_MWC,Pi_MWC); Phat(Zm_MT,Pi_MT);

    /*
        The approzimated Z statistic is now passed into the print function to
        be displayed to the monitor.
    */
    print(Pi_MWC, Pi_MT);
    cout<<"Computations took "<< double(clock()-start)/CLOCKS_PER_SEC<<
          " seconds for " << n << " simulations.\n\n\t";

    Pause ();

}

#include "4135FunctionLibrary.h"

////////////////////////////////////////////////////////////////////////////////
// This function finds the "order type" of (x0, x1, x2, x3, x4, x5, x6, x7).
// There are 8! = 40320 possible orderings.  The function returns
// a number n with 1 <= n <= 40320.  (1,2,3,4,5,6,7,8) is order type number 1,
// (8,7,6,5,4,3,2,1) is order type number 40320. But in general the order types
// are not lexicographically numbered.

int OrderType (double x0, double x1, double x2, double x3, double x4, double x5, double x6, double x7) {

   int type=1, i_min, i, k, step[]={5040, 720, 120, 24, 6, 2, 1};
   double x_min, x[10];

   // Put the data in a list.
   x[0] = x0; x[1] = x1; x[2] = x2; x[3] = x3;
   x[4] = x4; x[5] = x5; x[6] = x6; x[7] = x7;

   // Find the location of the k^th largest number among the remaining numbers.
   for (k = 0; k < 7; k++) {
      i_min = 0; x_min = x[0];
      for (i = 1; i < 8-k; i++)
         if (x[i] < x_min) {i_min = i; x_min = x[i];}

      type += step[k] * i_min;
      for (i = i_min; i < 7-k; i++)
         x[i] = x[i+1];
   }

   return (type);
}

void Xm(double Zm_MWC[], double Zm_MT[])
{
    //seed the Multiply with Carry and MERSENNE TWISTER
    //random number generators
    U1(45); U2(45);

    //this loop runs for the specified n simulations (which
    //is a global variable)
    for(int i=0; i<=n; i++){
        /*
            OrderType returns an integer used to bin the random
            vector in the respective bin. The array has 40320
            slots to store the number of times each permutation
            occurs. This is done for both random number generators
            and stored in the appropriate arrays.

            Note:you subtract one as the function OrderType
            returns an integer ranging from 1-40320 yet the array
            is 0 based. Thus the appropriate array of size 40320
            is indexed from 0-40319. In order to bin the vectors
            in the appropriate spots you must subtract 1 to have
            the new range of the returned integer genetated by
            OrderType be 0-40319 as needed.
        */

        Zm_MWC[OrderType(U1(0),U1(0),U1(0),U1(0),
                         U1(0),U1(0),U1(0),U1(0))-1]++;
        Zm_MT [OrderType(U2(0),U2(0),U2(0),U2(0),
                         U2(0),U2(0),U2(0),U2(0))-1]++;
    }
}

void Normalize(double Zm[])
{
    /*
        The values p, q, mu, sigma are assigned the appropriate
        values based on their distribution. The array Zm that
        is passed is really Xm and to get the appropriate values
        needed to approzimate the Z statistic these Xm's must be
        normalized
    */
    double p=1.0/40320, q=1-p, mu=n*p, sigma=sqrt(n*p*q);

    /*
        This loops through all the generated Xm's in the Zm array
        and normalizes them now making the array Zm truely an array
        of Zm values
    */
    for(int i=0; i<40320; i++)
        Zm[i]=(Zm[i]-mu)/sigma;
}

void Phat(double Zm[], double Pi[])
{
    /*
        This loop is used to indecate the number of
        Zm random variables lie between i and i+1.
        The number of times Zm fell in some range is
        stored in the appropriate array (i.e. Pi[0]
        indecates the number of Zm's that fall
        between -4 to -3, Pi[1] indecats the number
        of Zm between -3 to -2 ect...).

        i as stated before ranges from -4 to 3.
        Thus 8 slots must be availible in your array
        the full range we are testing is between -4
        to 4
    */
    for(int i=0; i<=40319; i++)
        if(Zm[i]>-4 && Zm[i]<=-3)       Pi[0]+=1;
        else if(Zm[i]>-3 && Zm[i]<=-2)  Pi[1]+=1;
        else if(Zm[i]>-2 && Zm[i]<=-1)  Pi[2]+=1;
        else if(Zm[i]>-1 && Zm[i]<=0)   Pi[3]+=1;
        else if(Zm[i]>0 && Zm[i]<=1)    Pi[4]+=1;
        else if(Zm[i]>1 && Zm[i]<=2)    Pi[5]+=1;
        else if(Zm[i]>2 && Zm[i]<=3)    Pi[6]+=1;
        else if(Zm[i]>3 && Zm[i]<=4)    Pi[7]+=1;

    /*
        This loop is used to go through the number
        of Zm that fall between i and i+1 (-4<1<=3)
        and divide through by the number of permutations.
        This indecates the fraction of times the Z
        statistic falls between i and i+1. This value
        should be approzimatey pi where pi is the
        probability z falls beteen i and i+1. The
        larger n (num of simulations) gets the closer
        (theoretically) these values should get to
        the actual z score. The closer the approzimate
        value for pi is the better the random number
        generator
    */
    for(int i=0; i<=7; i++)
        Pi[i]/=40320;
}

void print(double p1[], double p2[])
{
    /*
        sets and fixes the number of decimal places
        to be displayed to the monitor using the
        setprcision method. Also draws the top left
        most corner using a built in symbol
    */
    cout << fixed << setprecision(9) << (char)0xDa;

    //Draws the top line of the chart and the upper
    //right corner
    for(int i=1; i<=119; i++) cout << (char)0xC4;
    cout << (char)0xBF;

    /*
        displays the range of i for the z statistic and the left
        and right lines of the box
    */
    cout << "\n" << (char)0xB3 << "Range ";
    for(int i=-4; i<=3; i++)
        if(i<0) cout << "   " << "P(" << i << "<Z<=" << i+1 << ")";
        else    cout << "    " << " P(" << i << "<Z<=" << i+1 << ")";
    cout << "  " << (char)0xB3;


    //Skips a line and fills in missing parts of the box

    cout << "\n" << (char)0xB3;
    for(int i=0; i<=118; i++) cout << " ";
    cout << (char)0xB3;

    /*
        Displays the estimates Pi's generated by the MWC function
        and again draws another left and right line for the box
    */
    cout << "\n" << (char)0xB3 << "MWC   ";
    for(int i=0; i<=7; i++) cout << "   " << p1[i];
    cout << " " << (char)0xB3;

    /*
        Displays the estimates Pi's generated by the MT function
        and again draws another left and right line for the box
    */
    cout << "\n" << (char)0xB3 << "MT    ";
    for(int i=0; i<=7; i++) cout << "   " << p2[i] ;
    cout << " " << (char)0xB3;

    /*
        Displays the Actual probabilities generated by the normal
        distribution function.
    */
    cout << "\n" << (char)0xB3 << "ZScore   ";
    printN(); cout << (char)0xB3;

    /*
        Draws the bottom left and right most corners, and the rest
        of the box
    */
    cout << "\n" << (char)0xC0;
    for(int i=0; i<=118; i++) cout << (char)0xC4;
    cout << (char)0xD9 << "\n";

    /*
        The box that is diplayed to the monitor containing the
        results is purely for asthetic purposes and may be removed
        at any time
    */
}

void printN()
{
    /*
        This function is called to print or display to the monitor the probability
        i<Z<i+1.

        Again we fix and set the number of decimal points to be displayed to the
        monitor
    */
    cout << fixed << setprecision(9);
    cout << N(-3)-N(-4) << "   " << N(-2)-N(-3) << "   " << N(-1)-N(-2) << "   "
         << N(0) -N(-1) << "   " << N(1) -N(0)  << "   " << N(2) -N(1)  << "   "
         << N(3) -N(2)  << "   " << N(4) -N(3)  << " ";
}

double N(double d)
{
    /*
        This function finds the Zscore and returns it

        It was taken
        from http://stackoverflow.com/questions/2328258/cumulative-normal-distribution-function-in-c-c.
        It was tested and confirmed to  be quite accuracy.
    */
    const double A1=0.31938153,   A2=-0.356563782, A3=1.781477937,
                 A4=-1.821255978, A5=1.330274429,
                 RSQRT2PI=0.39894228040143267793994605993438;

    double K=1.0/(1.0+0.2316419*fabs(d)),
           cnd=RSQRT2PI*exp(-0.5*d*d)*(K*(A1+K*(A2+K*(A3+K*(A4+K*A5)))));

    if(d>0)cnd=1.0-cnd;

    return cnd;
}
